name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      skip_migrations:
        description: 'Skip Alembic migrations'
        required: false
        type: boolean
        default: false

env:
  GCP_REGION: ${{ vars.GCP_REGION }}
  ARTIFACT_REGISTRY: ${{ vars.ARTIFACT_REGISTRY }}
  PROD_PROJECT_ID: ${{ vars.PROD_PROJECT_ID }}

jobs:
  require-dev-success:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - name: Ensure dev deploy succeeded for this commit
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const defaultBranch = context.payload.repository.default_branch;
            const refName =
              context.ref_name ||
              (context.ref || "").replace("refs/heads/", "") ||
              context.payload.ref;
            if (refName !== defaultBranch) {
              core.setFailed(`Deploy to Production must be run from ${defaultBranch}. Current ref: ${refName}`);
              return;
            }

            const { data: branch } = await github.rest.repos.getBranch({
              owner,
              repo,
              branch: defaultBranch,
            });
            const mainSha = branch.commit.sha;

            const { data } = await github.request(
              "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
              {
                owner,
                repo,
                workflow_id: "deploy-dev.yml",
                branch: defaultBranch,
                status: "completed",
                per_page: 50,
              }
            );

            const successForHead = data.workflow_runs.find(
              (run) => run.head_sha === mainSha && run.conclusion === 'success'
            );

            if (!successForHead) {
              const latestSuccess = data.workflow_runs.find(
                (run) => run.conclusion === 'success'
              );
              const latestDesc = latestSuccess
                ? `${latestSuccess.head_sha.slice(0, 7)} (${latestSuccess.html_url})`
                : 'none';
              core.setFailed(
                `Deploy to Dev has not succeeded for current ${defaultBranch} HEAD ${mainSha.slice(0, 7)}. Latest successful dev deploy: ${latestDesc}. Run Deploy to Dev on the latest commit before deploying to prod.`
              );
            }

  # Build & push backend image (prod)
  build-backend-prod:
    needs: require-dev-success
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.image.outputs.name }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_PROD }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push
        id: image
        run: |
          IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROD_PROJECT_ID }}/app/backend:${{ github.sha }}"
          docker build -t $IMAGE -f backend/Dockerfile backend
          docker push $IMAGE
          echo "name=$IMAGE" >> $GITHUB_OUTPUT

  # Build & push frontend image (prod)
  build-frontend-prod:
    needs: require-dev-success
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.image.outputs.name }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_PROD }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push
        id: image
        run: |
          IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROD_PROJECT_ID }}/app/frontend:${{ github.sha }}"
          docker build -t $IMAGE -f frontend/Dockerfile \
            --build-arg VITE_ASSET_BUCKET=${{ vars.VITE_ASSET_BUCKET_PROD }} \
            frontend
          docker push $IMAGE
          echo "name=$IMAGE" >> $GITHUB_OUTPUT

  # Terraform apply to prod
  terraform-apply-prod:
    needs: [build-backend-prod, build-frontend-prod]
    runs-on: ubuntu-latest
    environment: prod  # Requires manual approval in GitHub
    permissions:
      contents: read
      id-token: write
    outputs:
      backend_url: ${{ steps.outputs.outputs.backend_url }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_PROD }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Resolve images
        run: |
          BACKEND_IMAGE="${{ needs.build-backend-prod.outputs.image }}"
          FRONTEND_IMAGE="${{ needs.build-frontend-prod.outputs.image }}"
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_REPO="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROD_PROJECT_ID }}/app"
          latest_tag() {
            local pkg="$1"
            gcloud artifacts docker images list "$pkg" --include-tags \
              --format="value(tags,updateTime)" --sort-by=~updateTime --limit=1 \
              | awk '{print $1}' | cut -d, -f1
          }
          if [ -z "$BACKEND_IMAGE" ]; then
            if gcloud artifacts docker images list "$IMAGE_REPO" --include-tags \
              --filter="package=${IMAGE_REPO}/backend AND tags:${IMAGE_TAG}" \
              --format="value(package)" | head -n 1 | grep -q backend; then
              BACKEND_IMAGE="${IMAGE_REPO}/backend:${IMAGE_TAG}"
            fi
          fi
          if [ -z "$FRONTEND_IMAGE" ]; then
            if gcloud artifacts docker images list "$IMAGE_REPO" --include-tags \
              --filter="package=${IMAGE_REPO}/frontend AND tags:${IMAGE_TAG}" \
              --format="value(package)" | head -n 1 | grep -q frontend; then
              FRONTEND_IMAGE="${IMAGE_REPO}/frontend:${IMAGE_TAG}"
            fi
          fi
          if [ -z "$BACKEND_IMAGE" ]; then
            LATEST_BACKEND_TAG=$(latest_tag "${IMAGE_REPO}/backend")
            if [ -n "$LATEST_BACKEND_TAG" ]; then
              BACKEND_IMAGE="${IMAGE_REPO}/backend:${LATEST_BACKEND_TAG}"
            fi
          fi
          if [ -z "$FRONTEND_IMAGE" ]; then
            LATEST_FRONTEND_TAG=$(latest_tag "${IMAGE_REPO}/frontend")
            if [ -n "$LATEST_FRONTEND_TAG" ]; then
              FRONTEND_IMAGE="${IMAGE_REPO}/frontend:${LATEST_FRONTEND_TAG}"
            fi
          fi
          if [ -z "$BACKEND_IMAGE" ] || [ -z "$FRONTEND_IMAGE" ]; then
            echo "Missing backend_image or frontend_image."
            echo "Build outputs are empty and no images were found for ${IMAGE_TAG} or latest Artifact Registry tags."
            exit 1
          fi
          echo "BACKEND_IMAGE=$BACKEND_IMAGE" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=$FRONTEND_IMAGE" >> $GITHUB_ENV

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0
          terraform_wrapper: false

      - name: Terraform init
        run: |
          cd infra/terraform/envs/prod
          terraform init

      - name: Terraform plan
        run: |
          cd infra/terraform/envs/prod
          terraform plan \
            -var-file=terraform.tfvars \
            -var="project_id=${{ env.PROD_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="vertex_region=${{ vars.VERTEX_REGION || env.GCP_REGION }}" \
            -var="backend_image=${{ env.BACKEND_IMAGE }}" \
            -var="frontend_image=${{ env.FRONTEND_IMAGE }}"

      - name: Terraform apply
        run: |
          cd infra/terraform/envs/prod
          terraform apply -auto-approve \
            -var-file=terraform.tfvars \
            -var="project_id=${{ env.PROD_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="vertex_region=${{ vars.VERTEX_REGION || env.GCP_REGION }}" \
            -var="backend_image=${{ env.BACKEND_IMAGE }}" \
            -var="frontend_image=${{ env.FRONTEND_IMAGE }}"

      - name: Get outputs
        id: outputs
        run: |
          cd infra/terraform/envs/prod
          BACKEND_URL=$(terraform output -raw backend_url)
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT

  # Run Alembic migrations against prod Cloud SQL
  run-migrations-prod:
    needs: terraform-apply-prod
    if: ${{ !inputs.skip_migrations }}
    runs-on: ubuntu-latest
    environment: prod  # Reuse prod environment approval for migrations
    permissions:
      contents: read
      id-token: write
    env:
      MODE: production
      PROJECT_NAME: fastapi-sqlmodel-alembic
      OPENAI_API_KEY: dummy
      REDIS_HOST: localhost
      REDIS_PORT: 6379
      BACKEND_CORS_ORIGINS: http://localhost

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_PROD }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip uv
          cd backend/app
          uv sync --frozen --no-install-project

      - name: Start Cloud SQL Proxy
        run: |
          wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy
          chmod +x cloud_sql_proxy
          ./cloud_sql_proxy -instances=${{ vars.PROD_SQL_INSTANCE_CONNECTION }}=tcp:5432 &
          sleep 5

      - name: Fetch DB password from Secret Manager
        run: |
          DB_PASSWORD=$(gcloud secrets versions access latest --secret="db-password" --project="${{ env.PROD_PROJECT_ID }}")
          ENCRYPT_KEY=$(gcloud secrets versions access latest --secret="encrypt-key" --project="${{ env.PROD_PROJECT_ID }}")
          echo "DATABASE_USER=${{ vars.PROD_DB_USER }}" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=${DB_PASSWORD}" >> $GITHUB_ENV
          echo "DATABASE_HOST=127.0.0.1" >> $GITHUB_ENV
          echo "DATABASE_PORT=5432" >> $GITHUB_ENV
          echo "DATABASE_NAME=${{ vars.PROD_DB_NAME }}" >> $GITHUB_ENV
          echo "ENCRYPT_KEY=${ENCRYPT_KEY}" >> $GITHUB_ENV

      - name: Extract Cloud SQL instance name
        run: |
          INSTANCE="${{ vars.PROD_SQL_INSTANCE_CONNECTION }}"
          echo "DB_INSTANCE=${INSTANCE##*:}" >> $GITHUB_ENV

      - name: Backup notification
        continue-on-error: true
        run: |
          echo "Ensure a recent DB backup exists before proceeding"
          gcloud sql backups list --instance="$DB_INSTANCE" --limit=1

      - name: Run migrations
        run: |
          cd backend/app
          uv run alembic upgrade head

      - name: Verify migration
        run: |
          cd backend/app
          uv run alembic current

  # Smoke test prod deployment
  smoke-test-prod:
    needs: [terraform-apply-prod, run-migrations-prod]
    if: always() && needs.terraform-apply-prod.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_PROD }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Health check
        run: |
          BACKEND_URL="${{ needs.terraform-apply-prod.outputs.backend_url }}"
          BACKEND_SERVICE="fastapi-backend"
          READY_ATTEMPTS=18
          READY_INTERVAL=10
          for i in $(seq 1 $READY_ATTEMPTS); do
            READY_STATUS=$(gcloud run services describe "$BACKEND_SERVICE" \
              --region "${{ env.GCP_REGION }}" \
              --project "${{ env.PROD_PROJECT_ID }}" \
              --format=json | python -c 'import json,sys; svc=json.load(sys.stdin); status=svc.get("status", {}); conds=status.get("conditions", []); ready=any(c.get("type")=="Ready" and c.get("status")=="True" for c in conds) or bool(status.get("latestReadyRevision") or status.get("latestReadyRevisionName")); print("True" if ready else "False")')
            if [ "$READY_STATUS" = "True" ]; then
              echo "Service Ready after $((i * READY_INTERVAL))s"
              break
            fi
            echo "Service not Ready yet (attempt $i/$READY_ATTEMPTS). Waiting ${READY_INTERVAL}s..."
            sleep $READY_INTERVAL
          done
          if [ "$READY_STATUS" != "True" ]; then
            echo "Service did not become Ready after $((READY_ATTEMPTS * READY_INTERVAL))s"
            exit 1
          fi
          consecutive_500=0
          for i in $(seq 1 9); do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$BACKEND_URL/health" || true)
            if [ "$STATUS" = "200" ]; then
              echo "Production deployment healthy"
              exit 0
            fi
            if [ "$STATUS" = "500" ]; then
              consecutive_500=$((consecutive_500+1))
              if [ "$consecutive_500" -ge 4 ]; then
                echo "Health check returned 500 four times; failing fast."
                exit 1
              fi
            else
              consecutive_500=0
            fi
            echo "Health check attempt $i/9 returned $STATUS. Retrying in 10s..."
            sleep 10
          done
          echo "Health check failed after 90 seconds"
          exit 1

      - name: Notify success
        run: |
          echo "Production deployed successfully"
          echo "Backend: ${{ needs.terraform-apply-prod.outputs.backend_url }}"

  notify-prod-success:
    needs: [terraform-apply-prod, smoke-test-prod]
    if: always() && needs.smoke-test-prod.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Send Google Chat success notification
        uses: SimonScholz/google-chat-action@main
        with:
          webhookUrl: ${{ secrets.GOOGLE_CHAT_WEBHOOK_PROD }}
          jobStatus: success
          title: "üéâ Production Deployment Successful"
          subtitle: "All systems operational"
          additionalSections: |
            [
              {
                "header": "üì¶ Deployed",
                "widgets": [
                  {
                    "decoratedText": {
                      "topLabel": "Backend Image",
                      "text": "${{ env.BACKEND_TAG }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Frontend Image",
                      "text": "${{ env.FRONTEND_TAG }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Deployed By",
                      "text": "${{ github.actor }}"
                    }
                  }
                ]
              },
              {
                "widgets": [
                  {
                    "buttonList": {
                      "buttons": [
                        {
                          "text": "View Production",
                          "onClick": {
                            "openLink": {
                              "url": "${{ needs.terraform-apply-prod.outputs.backend_url }}"
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            ]

  notify-prod-failure:
    needs: [terraform-apply-prod, run-migrations-prod, smoke-test-prod]
    if: always() && (needs.terraform-apply-prod.result == 'failure' || needs.run-migrations-prod.result == 'failure' || needs.smoke-test-prod.result == 'failure')
    runs-on: ubuntu-latest

    steps:
      - name: Send Google Chat failure alert
        uses: SimonScholz/google-chat-action@main
        with:
          webhookUrl: ${{ secrets.GOOGLE_CHAT_WEBHOOK_PROD }}
          jobStatus: failure
          title: "üö® Production Deployment FAILED"
          subtitle: "<users/all> Immediate action required"
          # mention: "<users/all>"
          additionalSections: |
            [
              {
                "header": "‚ùå Failed Stage",
                "widgets": [
                  {
                    "decoratedText": {
                      "topLabel": "Terraform",
                      "text": "${{ needs.terraform-apply-prod.result }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Migrations",
                      "text": "${{ needs.run-migrations-prod.result }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Smoke Test",
                      "text": "${{ needs.smoke-test-prod.result }}"
                    }
                  }
                ]
              },
              {
                "widgets": [
                  {
                    "buttonList": {
                      "buttons": [
                        {
                          "text": "View Failure Logs",
                          "onClick": {
                            "openLink": {
                              "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            ]
