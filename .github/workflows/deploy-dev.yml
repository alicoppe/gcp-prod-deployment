name: Deploy to Dev

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  GCP_REGION: ${{ vars.GCP_REGION }}
  ARTIFACT_REGISTRY: ${{ vars.ARTIFACT_REGISTRY }}
  DEV_PROJECT_ID: ${{ vars.DEV_PROJECT_ID }}

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      infra: ${{ steps.filter.outputs.infra }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'backend/app/alembic/**'
              - 'backend/Dockerfile'
            frontend:
              - 'frontend/**'
            infra:
              - 'infra/terraform/**'

  # Build & push backend image
  build-backend:
    needs: changes
    if: needs.changes.outputs.backend == 'true' || needs.changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.image.outputs.name }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_DEV }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push
        id: image
        run: |
          IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.DEV_PROJECT_ID }}/app/backend:${{ github.sha }}"
          docker build -t $IMAGE -f backend/Dockerfile backend
          docker push $IMAGE
          echo "name=$IMAGE" >> $GITHUB_OUTPUT

  # Build & push frontend image
  build-frontend:
    needs: changes
    if: needs.changes.outputs.frontend == 'true' || needs.changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.image.outputs.name }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_DEV }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push
        id: image
        run: |
          IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.DEV_PROJECT_ID }}/app/frontend:${{ github.sha }}"
          BACKEND_URL=$(gcloud run services describe fastapi-backend \
            --project "${{ env.DEV_PROJECT_ID }}" --region "${{ env.GCP_REGION }}" \
            --format="value(status.url)")
          if [ -z "$BACKEND_URL" ]; then
            echo "Backend URL not found; cannot build frontend with API URL."
            exit 1
          fi
          docker build -t $IMAGE -f frontend/Dockerfile \
            --build-arg VITE_ASSET_BUCKET=${{ vars.VITE_ASSET_BUCKET }} \
            --build-arg VITE_API_URL=$BACKEND_URL \
            frontend
          docker push $IMAGE
          echo "name=$IMAGE" >> $GITHUB_OUTPUT

  # Terraform apply to dev
  terraform-apply-dev:
    needs: [changes, build-backend, build-frontend]
    if: |
      (needs.changes.outputs.infra == 'true' ||
       needs.changes.outputs.backend == 'true' ||
       needs.changes.outputs.frontend == 'true') &&
      (needs.build-backend.result == 'success' ||
        (needs.changes.outputs.backend != 'true' && needs.changes.outputs.infra != 'true')) &&
      (needs.build-frontend.result == 'success' ||
        (needs.changes.outputs.frontend != 'true' && needs.changes.outputs.infra != 'true'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      backend_url: ${{ steps.outputs.outputs.backend_url }}

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_DEV }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_DEV }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0
          terraform_wrapper: false

      - name: Terraform init
        run: |
          cd infra/terraform/envs/dev
          terraform init

      - name: Clear tainted frontend (one-time recovery)
        run: |
          cd infra/terraform/envs/dev
          terraform untaint module.cloud_run.google_cloud_run_v2_service.frontend || true

      - name: Terraform apply
        run: |
          cd infra/terraform/envs/dev
          BACKEND_IMAGE="${{ needs.build-backend.outputs.image }}"
          FRONTEND_IMAGE="${{ needs.build-frontend.outputs.image }}"
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_REPO="${{ env.ARTIFACT_REGISTRY }}/${{ env.DEV_PROJECT_ID }}/app"
          latest_tag() {
            local pkg="$1"
            gcloud artifacts docker images list "$pkg" --include-tags \
              --format="value(tags,updateTime)" --sort-by=~updateTime --limit=1 \
              | awk '{print $1}' | cut -d, -f1
          }
          if [ -z "$BACKEND_IMAGE" ]; then
            BACKEND_IMAGE=$(gcloud run services describe fastapi-backend \
              --region "${{ env.GCP_REGION }}" \
              --project "${{ env.DEV_PROJECT_ID }}" \
              --format="value(spec.template.spec.containers[0].image)" || true)
          fi
          if [ -z "$FRONTEND_IMAGE" ]; then
            FRONTEND_IMAGE=$(gcloud run services describe fastapi-frontend \
              --region "${{ env.GCP_REGION }}" \
              --project "${{ env.DEV_PROJECT_ID }}" \
              --format="value(spec.template.spec.containers[0].image)" || true)
          fi
          if [ -z "$BACKEND_IMAGE" ]; then
            if gcloud artifacts docker images list "$IMAGE_REPO" --include-tags \
              --filter="package=${IMAGE_REPO}/backend AND tags:${IMAGE_TAG}" \
              --format="value(package)" | head -n 1 | grep -q backend; then
              BACKEND_IMAGE="${IMAGE_REPO}/backend:${IMAGE_TAG}"
            fi
          fi
          if [ -z "$FRONTEND_IMAGE" ]; then
            if gcloud artifacts docker images list "$IMAGE_REPO" --include-tags \
              --filter="package=${IMAGE_REPO}/frontend AND tags:${IMAGE_TAG}" \
              --format="value(package)" | head -n 1 | grep -q frontend; then
              FRONTEND_IMAGE="${IMAGE_REPO}/frontend:${IMAGE_TAG}"
            fi
          fi
          if [ -z "$BACKEND_IMAGE" ]; then
            LATEST_BACKEND_TAG=$(latest_tag "${IMAGE_REPO}/backend")
            if [ -n "$LATEST_BACKEND_TAG" ]; then
              BACKEND_IMAGE="${IMAGE_REPO}/backend:${LATEST_BACKEND_TAG}"
            fi
          fi
          if [ -z "$FRONTEND_IMAGE" ]; then
            LATEST_FRONTEND_TAG=$(latest_tag "${IMAGE_REPO}/frontend")
            if [ -n "$LATEST_FRONTEND_TAG" ]; then
              FRONTEND_IMAGE="${IMAGE_REPO}/frontend:${LATEST_FRONTEND_TAG}"
            fi
          fi
          TF_ARGS=""
          EXTRA_TF_ARGS=()
          DEV_ALLOWED_ORIGINS_RAW="${{ vars.DEV_ALLOWED_ORIGINS }}"
          DEV_ALLOWED_ORIGIN_REGEX_RAW="${{ vars.DEV_ALLOWED_ORIGIN_REGEX }}"
          if [ -n "$DEV_ALLOWED_ORIGINS_RAW" ]; then
            DEV_ALLOWED_ORIGINS_JSON=$(python -c "import json, os; raw=os.environ.get('DEV_ALLOWED_ORIGINS_RAW','').strip(); data = [] if not raw else (json.loads(raw) if raw.startswith('[') else [i.strip() for i in raw.split(',') if i.strip()]); print(json.dumps(data) if raw else '')")
            if [ -n "$DEV_ALLOWED_ORIGINS_JSON" ]; then
              EXTRA_TF_ARGS+=("-var=allowed_origins=$DEV_ALLOWED_ORIGINS_JSON")
            fi
          fi
          if [ -n "$DEV_ALLOWED_ORIGIN_REGEX_RAW" ]; then
            EXTRA_TF_ARGS+=("-var=allowed_origin_regex=$DEV_ALLOWED_ORIGIN_REGEX_RAW")
          fi
          if [ -n "$BACKEND_IMAGE" ]; then TF_ARGS="$TF_ARGS -var=backend_image=$BACKEND_IMAGE"; fi
          if [ -n "$FRONTEND_IMAGE" ]; then TF_ARGS="$TF_ARGS -var=frontend_image=$FRONTEND_IMAGE"; fi
          if [ -z "$BACKEND_IMAGE" ] || [ -z "$FRONTEND_IMAGE" ]; then
            echo "Missing backend_image or frontend_image."
            echo "Build outputs are empty and no existing service image or latest Artifact Registry tag was found."
            exit 1
          fi
          terraform apply -auto-approve \
            -input=false \
            -target=google_project_service.vpc_access_api \
            -target=google_vpc_access_connector.serverless \
            -target=module.cloud_run.google_project_service.run_api \
            -target=module.cloud_run.google_project_service.iam_api \
            -target=module.cloud_run.google_service_account.backend \
            -target=module.secret_access.google_project_service.secret_api \
            -target=module.secret_access.google_project_iam_member.backend_secret_accessor \
            -target=module.vertex_ai.google_project_service.vertex_api \
            -target=module.vertex_ai.google_project_iam_member.backend_vertex_user \
            -target=module.cloud_run.google_project_iam_member.backend_vpcaccess_user \
            -target=module.cloud_run.google_cloud_run_v2_service.backend \
            -var="project_id=${{ env.DEV_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="vertex_region=${{ vars.VERTEX_REGION || env.GCP_REGION }}" \
            $TF_ARGS "${EXTRA_TF_ARGS[@]}"
          BACKEND_URL_OVERRIDE=$(gcloud run services describe fastapi-backend \
            --region "${{ env.GCP_REGION }}" \
            --project "${{ env.DEV_PROJECT_ID }}" \
            --format="value(status.url)" || true)
          if [ -z "$BACKEND_URL_OVERRIDE" ]; then
            echo "Backend URL not found after backend apply."
            exit 1
          fi
          if [ -n "${{ vars.DEV_BACKEND_URL_OVERRIDE }}" ]; then
            BACKEND_URL_OVERRIDE="${{ vars.DEV_BACKEND_URL_OVERRIDE }}"
          fi
          TF_ARGS="$TF_ARGS -var=backend_url_override=$BACKEND_URL_OVERRIDE"
          terraform apply -auto-approve \
            -input=false \
            -var="project_id=${{ env.DEV_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="vertex_region=${{ vars.VERTEX_REGION || env.GCP_REGION }}" \
            $TF_ARGS "${EXTRA_TF_ARGS[@]}"

      - name: Get outputs
        id: outputs
        run: |
          cd infra/terraform/envs/dev
          BACKEND_URL=$(terraform output -raw backend_url)
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT

  # Run Alembic migrations against dev Cloud SQL
  run-migrations-dev:
    needs: [changes, terraform-apply-dev]
    if: needs.changes.outputs.backend == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      MODE: production
      PROJECT_NAME: fastapi-sqlmodel-alembic
      OPENAI_API_KEY: dummy
      REDIS_HOST: localhost
      REDIS_PORT: 6379
      BACKEND_CORS_ORIGINS: http://localhost

    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_DEV }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip uv
          cd backend/app
          uv sync --frozen --no-install-project

      - name: Start Cloud SQL Proxy
        run: |
          wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy
          chmod +x cloud_sql_proxy
          ./cloud_sql_proxy -instances=${{ vars.DEV_SQL_INSTANCE_CONNECTION }}=tcp:5432 &
          sleep 5

      - name: Fetch DB password from Secret Manager
        run: |
          DB_PASSWORD=$(gcloud secrets versions access latest --secret="db-password" --project="${{ env.DEV_PROJECT_ID }}")
          ENCRYPT_KEY=$(gcloud secrets versions access latest --secret="encrypt-key" --project="${{ env.DEV_PROJECT_ID }}")
          echo "DATABASE_USER=${{ vars.DEV_DB_USER }}" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=${DB_PASSWORD}" >> $GITHUB_ENV
          echo "DATABASE_HOST=127.0.0.1" >> $GITHUB_ENV
          echo "DATABASE_PORT=5432" >> $GITHUB_ENV
          echo "DATABASE_NAME=${{ vars.DEV_DB_NAME }}" >> $GITHUB_ENV
          echo "ENCRYPT_KEY=${ENCRYPT_KEY}" >> $GITHUB_ENV

      - name: Run migrations
        run: |
          cd backend/app
          uv run alembic upgrade head

      - name: Seed initial data (dev only)
        run: |
          cd backend/app
          FIRST_SUPERUSER_EMAIL="admin@example.com" \
          FIRST_SUPERUSER_PASSWORD="admin" \
          uv run python app/initial_data.py

      - name: Verify migration
        run: |
          cd backend/app
          uv run alembic current

  # Smoke test dev deployment
  smoke-test-dev:
    needs: [terraform-apply-dev, run-migrations-dev]
    if: always() && needs.terraform-apply-dev.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER_DEV }}
          service_account: ${{ vars.GCP_SA_TERRAFORM_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Health check
        run: |
          BACKEND_URL="${{ needs.terraform-apply-dev.outputs.backend_url }}"
          BACKEND_SERVICE="fastapi-backend"
          READY_ATTEMPTS=12
          READY_INTERVAL=10
          for i in $(seq 1 $READY_ATTEMPTS); do
            READY_STATUS=$(gcloud run services describe "$BACKEND_SERVICE" \
              --region "${{ env.GCP_REGION }}" \
              --project "${{ env.DEV_PROJECT_ID }}" \
              --format=json | python -c 'import json,sys; svc=json.load(sys.stdin); status=svc.get("status", {}); conds=status.get("conditions", []); ready=any(c.get("type")=="Ready" and c.get("status")=="True" for c in conds) or bool(status.get("latestReadyRevision") or status.get("latestReadyRevisionName")); print("True" if ready else "False")')
            if [ "$READY_STATUS" = "True" ]; then
              echo "Service Ready after $((i * READY_INTERVAL))s"
              break
            fi
            echo "Service not Ready yet (attempt $i/$READY_ATTEMPTS). Waiting ${READY_INTERVAL}s..."
            sleep $READY_INTERVAL
          done
          if [ "$READY_STATUS" != "True" ]; then
            echo "Service did not become Ready after $((READY_ATTEMPTS * READY_INTERVAL))s"
            exit 1
          fi
          consecutive_500=0
          for i in $(seq 1 6); do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$BACKEND_URL/health" || true)
            if [ "$STATUS" = "200" ]; then
              echo "Dev deployment healthy"
              exit 0
            fi
            if [ "$STATUS" = "500" ]; then
              consecutive_500=$((consecutive_500+1))
              if [ "$consecutive_500" -ge 3 ]; then
                echo "Health check returned 500 three times; failing fast."
                exit 1
              fi
            else
              consecutive_500=0
            fi
            echo "Health check attempt $i/6 returned $STATUS. Retrying in 10s..."
            sleep 10
          done
          echo "Health check failed after 60 seconds"
          exit 1

  # Notify Google Chat that dev is ready
  notify-dev-success:
    needs: [smoke-test-dev, build-backend, build-frontend]
    if: always() && needs.smoke-test-dev.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Send Google Chat notification
        uses: SimonScholz/google-chat-action@main
        with:
          webhookUrl: ${{ secrets.GOOGLE_CHAT_WEBHOOK_DEV }}
          jobStatus: ${{ job.status }}
          title: "âœ… Dev Deployment Successful"
          subtitle: "Ready for production deployment"
          additionalSections: |
            [
              {
                "header": "ðŸ“¦ Deployment Details",
                "widgets": [
                  {
                    "decoratedText": {
                      "topLabel": "Commit",
                      "text": "${{ github.sha }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Author",
                      "text": "${{ github.actor }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Backend Image",
                      "text": "${{ needs.build-backend.outputs.image }}"
                    }
                  },
                  {
                    "decoratedText": {
                      "topLabel": "Frontend Image",
                      "text": "${{ needs.build-frontend.outputs.image }}"
                    }
                  }
                ]
              },
              {
                "header": "ðŸš€ Next Steps",
                "widgets": [
                  {
                    "buttonList": {
                      "buttons": [
                        {
                          "text": "Deploy to Production",
                          "onClick": {
                            "openLink": {
                              "url": "https://github.com/${{ github.repository }}/actions/workflows/deploy-prod.yml"
                            }
                          }
                        },
                        {
                          "text": "View Logs",
                          "onClick": {
                            "openLink": {
                              "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            ]
